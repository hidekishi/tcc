METODOLOGIA DE ADAPTAÇÃO DE GRANULARIDADE
==========================================

Para cada uma das oito aplicações principais do benchmark, foram desenvolvidas três variantes com diferentes estratégias de granularidade: a versão "standard" mantém a implementação OpenMP original com scheduling padrão; a versão "fine-grained" adota granularidade fina com scheduling dinâmico e chunks pequenos; e a versão "coarse-grained" emprega granularidade grossa com scheduling estático e chunks grandes. As adaptações foram implementadas através da modificação da cláusula schedule() nas diretivas parallel for e do ajuste dos parâmetros de cutoff em construções baseadas em tasks.

No benchmark Pi (integração numérica), a versão fine-grained utiliza schedule(dynamic, 1) para distribuir iterações individualmente entre threads, enquanto a coarse-grained emprega schedule(static, N/(threads×4)) com chunks grandes contíguos. No Mandelbrot Set, devido à alta irregularidade do workload (pontos convergem em tempos distintos), a versão fine usa schedule(dynamic, 10) para balanceamento dinâmico, enquanto a coarse mantém chunks estáticos que podem causar desbalanceamento. Para QuickSort, a granularidade foi controlada através do threshold de criação de tasks: fine-grained utiliza if(right-left > 1000) gerando mais paralelismo em subproblemas menores, enquanto coarse-grained emprega if(right-left > 100000) limitando tasks a partições grandes. No FFT, as versões diferem no cutoff de recursão paralela: fine-grained paraleliza até arrays de 64 elementos (schedule(dynamic, 1)), enquanto coarse-grained limita paralelização a arrays maiores que 4096 elementos (schedule(static)). 

O solver iterativo Jacobi teve suas variantes ajustadas no scheduling dos loops aninhados: fine-grained usa schedule(dynamic, 4) nas iterações da grade para compensar possível desbalanceamento nas bordas, enquanto coarse-grained adota schedule(static, m/threads) com chunks calculados para minimizar sincronização. Na decomposição LU, a adaptação focou no scheduling do loop de eliminação gaussiana: fine-grained emprega schedule(dynamic, 2) para balancear o workload decrescente ao longo das iterações, enquanto coarse-grained mantém schedule(static) com chunks grandes mesmo com carga desbalanceada. A simulação de Molecular Dynamics teve o loop de cálculo de forças adaptado: fine-grained utiliza schedule(dynamic, 8) pois partículas têm diferentes números de vizinhos, enquanto coarse-grained usa schedule(static) assumindo distribuição uniforme. Finalmente, no Graph Search, a granularidade do pool de trabalho foi ajustada: fine-grained processa um nó por acesso crítico ao pool (máxima granularidade), enquanto coarse-grained processa batches de 10 nós por acesso (reduzindo contenção na seção crítica). Estas adaptações permitem avaliar empiricamente o trade-off entre overhead de paralelização e eficiência de balanceamento de carga sob diferentes condições de workload e contagem de threads.
